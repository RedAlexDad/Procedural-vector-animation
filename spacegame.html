<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>HTML5</title>
	<!--[if IE]>
   <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
	<style>
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas" width="800px" height="600px" style="border: 2px solid red;"></canvas>
	<button onclick="startAnim();">START</button>
</body>
<script>
	var started = false;
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

	const SWidth = 800; // Ширина сцены (canvas)
	const SHeight = 600; // Высота сцены
	const PerspX = 0; // Центр перспективы 0 в новой системе координат - в центре canvas
	const PerspY = -100; // Центр перспективы по Y опускаем вниз на 100 пикселей
	const PCenter = {
		x: PerspX,
		y: PerspY
	}; // Центр перспективы в виде объекта
	const PLeft = {
		x: -SWidth / 2,
		y: PerspY
	};
	const PRight = {
		x: SWidth / 2,
		y: PerspY
	};

	const maxBotPerspTan = (SHeight / 2 + PerspY) / (SWidth / 2);
	const maxTopPerspTan = (SHeight / 2 - PerspY) / (SWidth / 2);

	function drawPerspective() {
		// Верхние линии перспективы
		ctx.strokeStyle = "rgb(0, 150, 150)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath()

		// Нижние линии перспективы
		ctx.strokeStyle = "rgb(0, 0, 0)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, -SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, -SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath();

		// Линия горизонта
		ctx.strokeStyle = "rgb(0, 250, 250)";
		ctx.moveTo(-SWidth / 2, PerspY);
		ctx.lineTo(SWidth / 2, PerspY);
		ctx.stroke(); // Render the path	
		ctx.closePath()
	}

	function drawAxes() {
		ctx.font = "12px serif";
		ctx.strokeStyle = "red";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(50, 0);
		ctx.stroke(); // Render the path
		ctx.closePath()
		ctx.fillText("X", 50, 10);

		ctx.strokeStyle = "blue";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(0, 50);
		ctx.stroke(); // Render the path
		ctx.closePath()
		ctx.fillText("Y", 0, 50);
	}

	drawAxes(); // Оси перед трансформацией

	//setTransform(a, b, c, d, e, f) - задать матрицу трансформаций для всех остальных рисований
	//	a	c	e
	//	b	d	f
	//	0	0	1
	// Cледющая трансформация сдвигает ось вправо на 400 пикселей и вниз на 300, т.е. в центр canvas
	// и отражает ось Y вверх (-1 в параметре d)
	ctx.setTransform(1, 0, 0, -1, 800 / 2, 600 / 2);
	drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается


	function resize(c, k, val) {
		return c + k * (val - c);
	}

	function moveToPoint(point) {
		ctx.moveTo(point.x, point.y);
	}

	function lineToPoint(point) {
		ctx.lineTo(point.x, point.y);
	}

	class point {
		// При конструировании присылаем объект - другую точку для копирования или просто JS-объект вида {x: 10, y: 12}
		constructor(pointObj = null) {
			if (pointObj && pointObj.x && pointObj.y) {
				this.x = pointObj.x;
				this.y = pointObj.y;
			} else {
				this.x = 0;
				this.y = 0;
			}
		}

		// Функции с окончанием -d не меняют текущий объект, а лишь возвращают временные пересчитанные координаты
		// это пригодиться для отрисовки базовых точек с искажением по времени без потери исходных координат
		moved(dx, dy) {
			return {
				x: this.x + dx,
				y: this.y + dy
			}
		}
		// Специально базирую функцию, меняющую объект на той, что не меняет, чтобы избежать повторения кода и чтобы обе функции работали одинаково
		// Таким образом если я поменяю чтото в формуле одной из них, то я не забуду сделать такое же изменение в другой
		move(dx, dy) {
			let moved = this.moved(dx, dy);
			this.x = moved.x;
			this.y = moved.y;
		}

		resized(centerPoint, k) {
			return {
				x: centerPoint.x + k * (this.x - centerPoint.x),
				y: centerPoint.y + k * (this.y - centerPoint.y)
			}
		}
		resize(centerPoint, k) {
			let resized = this.resized(centerPoint, k)
			this.x = resized.x;
			this.y = resized.y;
		}

		rotated(centerPoint, angle, isGrad = true) {
			if (isGrad) angle = angle * Math.PI / 180;
			return {
				x: (this.x - centerPoint.x) * Math.cos(angle) - (this.y - centerPoint.y) * Math.sin(angle) +
					centerPoint.x,
				y: (this.x - centerPoint.x) * Math.sin(angle) + (this.y - centerPoint.y) * Math.cos(angle) +
					centerPoint.y
			}
		}
		rotate(centerPoint, angle, isGrad = true) {
			let rotated = this.rotated(centerPoint, angle, isGrad);
			this.x = rotated.x;
			this.y = rotated.y;
		}

		dist2(pointObj = null) {
			let dx = 0;
			let dy = 0;

			if (pointObj && pointObj.x && pointObj.y) {
				dx = pointObj.x;
				dy = pointObj.y;
			}

			let dist = Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
			console.log(this, dx, dy, dist);
			return Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
		}
		dist(pointObj = null) {
			return Math.sqrt(this.dist2(pointObj));
		}
	}

	class building {
		constructor(baseT) {
			this.baseT = baseT;
			this.widthRandCoef = Math.random() * 2 - 1;
			this.heighRandCoef = Math.random() * 2 - 1;
			this.depthRandCoef = Math.random() * 2 - 1;

			this.baseRotRand = Math.random() * Math.atan(maxBotPerspTan);

			this.isLeft = -1;

			this.dist = 0;

			// Ключевые точки рисования мы можем просчитать один раз для позиции t=1, а непосредственно при отрисовке из просто скалировать
			this.base = new point({
				x: (PerspX - SWidth / 4) * this.isLeft,
				y: PerspY - maxBotPerspTan * (PerspX + SWidth / 4)
			});
			this.base.rotate(PCenter, this.baseRotRand, false);

			// Берем верхнюю точку здания как горизонтальный сдвиг вверх на 300рх (с коэф рандомности)
			this.topBase = new point(this.base);
			this.topBase.move(0, 300 + 200 * this.heighRandCoef);

			// Левый край прямоугольника задается как запаздывание от стандартной отрисовки 1 в 0.3
			this.topLeft = new point(this.topBase);
			this.topLeft.resize(PCenter, 1 - 0.3 + 0.2 * this.widthRandCoef);

			// Аналогично, левая нижняя точка прямоугольно - запаздывание по коэфициенту базовой точки (baseX, baseY)
			this.baseLeft = new point(this.base);
			this.baseLeft.resize(PCenter, 1 - 0.3 + 0.2 * this.widthRandCoef)


			// Правый край как приближение к правой точке перспективы
			this.baseSide = new point(this.base);
			this.baseSide.resize(PRight, 1 - 0.3 + 0.2 * this.depthRandCoef);

			this.topSide = new point(this.topBase);
			this.topSide.resize(PRight, 1 - 0.3 + 0.2 * this.depthRandCoef)
		}

		draw(t) {
			ctx.strokeStyle = "black";
			ctx.fillStyle = "rgb(250,250,250)";
			ctx.beginPath();

			let baseK = 1 * (t - this.baseT) / 100;

			// перед рисованием пересчитываем масштаб в зависимости от t, получаем basePoint на нужном по времени месте
			// причем первые две мы сохраняем в локальные переменные, потому как в них ещё придётся возвращаться
			let basePoint = this.base.resized(PCenter, baseK);
			moveToPoint(basePoint);

			let topBasePoint = this.topBase.resized(PCenter, baseK);
			lineToPoint(topBasePoint);

			lineToPoint(this.topLeft.resized(PCenter, baseK));

			lineToPoint(this.baseLeft.resized(PCenter, baseK));

			// Замыкаем прямоугольник в базовой точке, пересчитанной на коэф t
			lineToPoint(basePoint);

			//ctx.stroke();
			ctx.fill();
			ctx.closePath()

			ctx.fillStyle = "rgb(200,200,230)";
			ctx.beginPath();
			lineToPoint(this.baseSide.resized(PCenter, baseK));
			lineToPoint(this.topSide.resized(PCenter, baseK));
			lineToPoint(topBasePoint);
			lineToPoint(basePoint);

			ctx.fill();
			ctx.closePath()

		}
	}

	let bui = new building(1);
	//let bui2 = new building(1.2);

	let t = 100;

	function startAnim() {
		setInterval(() => {
			ctx.clearRect(-SWidth / 2, -SHeight / 2, SWidth, SHeight);
			bui.draw(t);
			//bui2.draw(t);
			drawPerspective();
			t = t * 1.05;

			if (t > 450) {
				t = 1;
				bui = new building(1);
				//bu2 = new building(166);
			}

			drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается

		}, 16);
	}

	// Управление мышкой
	const square = {
		x: canvas.width / 2,
		y: canvas.height / 2,
		size: 50,
		isDragging: false,
		offsetX: 0,
		offsetY: 0
	};

	function drawSquare(x, y, size) {
		ctx.fillStyle = "blue";
		ctx.fillRect(x - size / 2, y - size / 2, size, size);
	}

	canvas.addEventListener("mousedown", (e) => {
		const mouseX = e.clientX - canvas.getBoundingClientRect().left;
		const mouseY = e.clientY - canvas.getBoundingClientRect().top;

		if (
			mouseX >= square.x - square.size / 2 &&
			mouseX <= square.x + square.size / 2 &&
			mouseY >= square.y - square.size / 2 &&
			mouseY <= square.y + square.size / 2
		) {
			square.isDragging = true;
			square.offsetX = mouseX - square.x;
			square.offsetY = mouseY - square.y;
		}
	});

	canvas.addEventListener("mousemove", (e) => {
		if (square.isDragging) {
			const mouseX = e.clientX - canvas.getBoundingClientRect().left;
			const mouseY = e.clientY - canvas.getBoundingClientRect().top;

			square.x = mouseX - square.offsetX;
			square.y = mouseY - square.offsetY;

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawSquare(square.x, square.y, square.size);
		}
	});

	canvas.addEventListener("mouseup", () => {
		square.isDragging = false;
	});

	function animate() {
		requestAnimationFrame(animate);
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawSquare(square.x, square.y, square.size);
	}

	animate();
</script>

</html>