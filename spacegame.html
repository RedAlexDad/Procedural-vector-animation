<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>HTML5</title>
	<!--[if IE]>
   <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
	<style>
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas" width="800px" height="600px" style="border: 2px solid red;"></canvas>
	<button onclick="startAnim();">START</button>
</body>
<script>
	var started = false;
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

	const SWidth = canvas.width; // Ширина сцены (canvas)
	const SHeight = canvas.height; // Высота сцены
	const PerspX = SWidth / 2; // Центр перспективы 0 в новой системе координат - в центре canvas
	const PerspY = SHeight / 2; // Центр перспективы по Y опускаем вниз на 100 пикселей
	const PCenter = {
		x: PerspX,
		y: PerspY
	}; // Центр перспективы в виде объекта
	const PLeft = {
		x: -SWidth / 2,
		y: PerspY
	};
	const PRight = {
		x: SWidth / 2,
		y: PerspY
	};

	const maxBotPerspTan = (SHeight / 2 + PerspY) / (SWidth / 2);
	const maxTopPerspTan = (SHeight / 2 - PerspY) / (SWidth / 2);

	function drawPerspective() {
		// Отрисовка перспективных линий
		ctx.strokeStyle = "rgb(0, 150, 150)";
		ctx.beginPath();
		ctx.moveTo(0, SHeight);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth, SHeight);
		ctx.stroke();
		ctx.closePath();

		ctx.strokeStyle = "rgb(0, 0, 0)";
		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth, 0);
		ctx.stroke();
		ctx.closePath();

		ctx.strokeStyle = "rgb(0, 250, 250)";
		ctx.beginPath();
		ctx.moveTo(0, PerspY);
		ctx.lineTo(SWidth, PerspY);
		ctx.stroke();
		ctx.closePath();
	}

	function drawAxes() {
		// Отрисовка осей
		ctx.strokeStyle = "red";
		ctx.beginPath();
		ctx.moveTo(0, PerspY);
		ctx.lineTo(SWidth, PerspY);
		ctx.stroke();
		ctx.closePath();

		ctx.strokeStyle = "blue";
		ctx.beginPath();
		ctx.moveTo(PerspX, 0);
		ctx.lineTo(PerspX, SHeight);
		ctx.stroke();
		ctx.closePath();
	}

	drawAxes(); // Оси перед трансформацией

	function drawRocket(x, y) {
		ctx.fillStyle = "red";
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x - 25, y + 50);
		ctx.lineTo(x + 25, y + 50);
		ctx.closePath();
		ctx.fill();

		ctx.fillStyle = "blue";
		ctx.fillRect(x - 25, y + 50, 50, 10);
	}

	let rocketX = PerspX;
	let rocketY = PerspY;

	function updateRocketPosition(event) {
		rocketX = event.clientX - canvas.getBoundingClientRect().left - canvas.width / 2;
		rocketY = event.clientY - canvas.getBoundingClientRect().top - canvas.height / 2;
	}	

	canvas.addEventListener("mousemove", updateRocketPosition);

	function animateRocket() {
		ctx.clearRect(0, 0, SWidth, SHeight);
		drawPerspective();
		drawRocket(rocketX, rocketY);
		drawAxes();
		requestAnimationFrame(animateRocket);
	}

	animateRocket();

	//setTransform(a, b, c, d, e, f) - задать матрицу трансформаций для всех остальных рисований
	//	a	c	e
	//	b	d	f
	//	0	0	1
	// Cледющая трансформация сдвигает ось вправо на 400 пикселей и вниз на 300, т.е. в центр canvas
	// и отражает ось Y вверх (-1 в параметре d)
	ctx.setTransform(1, 0, 0, -1, 800 / 2, 600 / 2);
	drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается


	function resize(c, k, val) {
		return c + k * (val - c);
	}

	function moveToPoint(point) {
		ctx.moveTo(point.x, point.y);
	}

	function lineToPoint(point) {
		ctx.lineTo(point.x, point.y);
	}

	class point {
		// При конструировании присылаем объект - другую точку для копирования или просто JS-объект вида {x: 10, y: 12}
		constructor(pointObj = null) {
			if (pointObj && pointObj.x && pointObj.y) {
				this.x = pointObj.x;
				this.y = pointObj.y;
			} else {
				this.x = 0;
				this.y = 0;
			}
		}

		// Функции с окончанием -d не меняют текущий объект, а лишь возвращают временные пересчитанные координаты
		// это пригодиться для отрисовки базовых точек с искажением по времени без потери исходных координат
		moved(dx, dy) {
			return {
				x: this.x + dx,
				y: this.y + dy
			}
		}
		// Специально базирую функцию, меняющую объект на той, что не меняет, чтобы избежать повторения кода и чтобы обе функции работали одинаково
		// Таким образом если я поменяю чтото в формуле одной из них, то я не забуду сделать такое же изменение в другой
		move(dx, dy) {
			let moved = this.moved(dx, dy);
			this.x = moved.x;
			this.y = moved.y;
		}

		resized(centerPoint, k) {
			return {
				x: centerPoint.x + k * (this.x - centerPoint.x),
				y: centerPoint.y + k * (this.y - centerPoint.y)
			}
		}
		resize(centerPoint, k) {
			let resized = this.resized(centerPoint, k)
			this.x = resized.x;
			this.y = resized.y;
		}

		rotated(centerPoint, angle, isGrad = true) {
			if (isGrad) angle = angle * Math.PI / 180;
			return {
				x: (this.x - centerPoint.x) * Math.cos(angle) - (this.y - centerPoint.y) * Math.sin(angle) +
					centerPoint.x,
				y: (this.x - centerPoint.x) * Math.sin(angle) + (this.y - centerPoint.y) * Math.cos(angle) +
					centerPoint.y
			}
		}
		rotate(centerPoint, angle, isGrad = true) {
			let rotated = this.rotated(centerPoint, angle, isGrad);
			this.x = rotated.x;
			this.y = rotated.y;
		}

		dist2(pointObj = null) {
			let dx = 0;
			let dy = 0;

			if (pointObj && pointObj.x && pointObj.y) {
				dx = pointObj.x;
				dy = pointObj.y;
			}

			let dist = Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
			console.log(this, dx, dy, dist);
			return Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
		}
		dist(pointObj = null) {
			return Math.sqrt(this.dist2(pointObj));
		}
	}

	class building {
		constructor(baseT) {
			this.baseT = baseT;
			this.widthRandCoef = Math.random() * 2 - 1;
			this.heighRandCoef = Math.random() * 2 - 1;
			this.depthRandCoef = Math.random() * 2 - 1;

			this.baseRotRand = Math.random() * Math.atan(maxBotPerspTan);

			this.isLeft = -1;

			this.dist = 0;

			// Ключевые точки рисования мы можем просчитать один раз для позиции t=1, а непосредственно при отрисовке из просто скалировать
			this.base = new point({
				x: (PerspX - SWidth / 4) * this.isLeft,
				y: PerspY - maxBotPerspTan * (PerspX + SWidth / 4)
			});
			this.base.rotate(PCenter, this.baseRotRand, false);

			// Берем верхнюю точку здания как горизонтальный сдвиг вверх на 300рх (с коэф рандомности)
			this.topBase = new point(this.base);
			this.topBase.move(0, 300 + 200 * this.heighRandCoef);

			// Левый край прямоугольника задается как запаздывание от стандартной отрисовки 1 в 0.3
			this.topLeft = new point(this.topBase);
			this.topLeft.resize(PCenter, 1 - 0.3 + 0.2 * this.widthRandCoef);

			// Аналогично, левая нижняя точка прямоугольно - запаздывание по коэфициенту базовой точки (baseX, baseY)
			this.baseLeft = new point(this.base);
			this.baseLeft.resize(PCenter, 1 - 0.3 + 0.2 * this.widthRandCoef)


			// Правый край как приближение к правой точке перспективы
			this.baseSide = new point(this.base);
			this.baseSide.resize(PRight, 1 - 0.3 + 0.2 * this.depthRandCoef);

			this.topSide = new point(this.topBase);
			this.topSide.resize(PRight, 1 - 0.3 + 0.2 * this.depthRandCoef)
		}

		draw(t) {
			ctx.strokeStyle = "black";
			ctx.fillStyle = "rgb(250,250,250)";
			ctx.beginPath();

			let baseK = 1 * (t - this.baseT) / 100;

			// перед рисованием пересчитываем масштаб в зависимости от t, получаем basePoint на нужном по времени месте
			// причем первые две мы сохраняем в локальные переменные, потому как в них ещё придётся возвращаться
			let basePoint = this.base.resized(PCenter, baseK);
			moveToPoint(basePoint);

			let topBasePoint = this.topBase.resized(PCenter, baseK);
			lineToPoint(topBasePoint);

			lineToPoint(this.topLeft.resized(PCenter, baseK));

			lineToPoint(this.baseLeft.resized(PCenter, baseK));

			// Замыкаем прямоугольник в базовой точке, пересчитанной на коэф t
			lineToPoint(basePoint);

			//ctx.stroke();
			ctx.fill();
			ctx.closePath()

			ctx.fillStyle = "rgb(200,200,230)";
			ctx.beginPath();
			lineToPoint(this.baseSide.resized(PCenter, baseK));
			lineToPoint(this.topSide.resized(PCenter, baseK));
			lineToPoint(topBasePoint);
			lineToPoint(basePoint);

			ctx.fill();
			ctx.closePath()

		}
	}

	let bui = new building(1);
	//let bui2 = new building(1.2);

	let t = 100;

	function startAnim() {
		setInterval(() => {
			ctx.clearRect(-SWidth / 2, -SHeight / 2, SWidth, SHeight);
			bui.draw(t);
			//bui2.draw(t);
			drawPerspective();
			t = t * 1.05;

			if (t > 450) {
				t = 1;
				bui = new building(1);
				//bu2 = new building(166);
			}

			drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается

		}, 16);
	}
</script>

</html>