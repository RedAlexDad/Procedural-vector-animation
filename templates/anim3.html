<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>HTML5</title>
	<!--[if IE]>
   <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
	<style>
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas" width="800px" height="600px" style="border: 2px solid red;"></canvas>
	<button onclick="startAnim();">START</button>
</body>
<script>
	var started = false;
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

	const SWidth = 800;						// Ширина сцены (canvas)
	const SHeight = 600;					// Высота сцены
	const PerspX = 0;						// Центр перспективы 0 в новой системе координат - в центре canvas
	const PerspY = -100;					// Центр перспективы по Y опускаем вниз на 100 пикселей

	const maxBotPerspAngle = (-SHeight/2-PerspY) / (SWidth/2);
	console.log(maxBotPerspAngle)

	function drawPerspective() {
		// Верхние линии перспективы
		ctx.strokeStyle = "rgb(0, 150, 150)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath()

		// Нижние линии перспективы
		ctx.strokeStyle = "rgb(0, 0, 0)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, -SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, -SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath();

		// Линия горизонта
		ctx.strokeStyle = "rgb(0, 250, 250)";
		ctx.moveTo(-SWidth / 2, PerspY);
		ctx.lineTo(SWidth / 2, PerspY);
		ctx.stroke(); // Render the path	
		ctx.closePath()
	}

	function drawAxes() {
  		ctx.font = "12px serif";
		ctx.strokeStyle = "red";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(50, 0);
		ctx.stroke(); // Render the path
		ctx.closePath()
  		ctx.fillText("X", 50, 10);

		ctx.strokeStyle = "blue";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(0, 50);
		ctx.stroke(); // Render the path
		ctx.closePath()
  		ctx.fillText("Y", 0, 50);
	}

	drawAxes(); // Оси перед трансформацией

	//setTransform(a, b, c, d, e, f) - задать матрицу трансформаций для всех остальных рисований
	//	a	c	e
	//	b	d	f
	//	0	0	1
	// Cледющая трансформация сдвигает ось вправо на 400 пикселей и вниз на 300, т.е. в центр canvas
	// и отражает ось Y вверх (-1 в параметре d)
	ctx.setTransform(1, 0, 0, -1, 800 / 2, 600 / 2);
	drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается


	function resize(c, k, val) {
		return c + k * (val - c);
	}

	class building {
		constructor(baseT) {
			this.baseT = baseT;
			this.widthRandCoef = Math.random()*2-1;
			this.heighRandCoef = 0;
			this.depthRandCoef = 1;

			this.isLeft = Math.floor(Math.random() * 2) > 0 ? -1 : 1;

			this.dist = 0;
		}

		draw(t) {

			let baseK = 1*(t-this.baseT)/100;
			let baseX = (PerspX-SWidth/4)*this.isLeft;
			let baseY = PerspY + maxBotPerspAngle*(PerspX+SWidth/4);

			let baseXt = resize(PerspX, baseK, baseX);
			let baseYt = resize(PerspY, baseK, baseY);
			console.log(baseX, baseY)
			
			ctx.strokeStyle = "black";
			ctx.beginPath();
			ctx.moveTo(baseXt, baseYt);

			// Берем верхнюю точку здания как горизонтальный сдвиг вверх на 300рх (с коэф рандомности)
			let topBaseX = baseX;
			let topBaseY = baseY + 300 + 200*this.heighRandCoef;

			// перед рисованием пересчитываем масштаб в зависимости от t, получаем topBaseYt
			let topBaseXt = baseXt;
			let topBaseYt = resize(PerspY, baseK, topBaseY);
			ctx.lineTo(topBaseXt, topBaseYt);

			// Левый край прямоугольника задается как запаздывание от стандартной отрисовки 1 в 0.2
			let leftK = 1-0.3 + 0.2*this.widthRandCoef;
			let topLeftX = resize(PerspX, leftK, topBaseX);
			let topLeftY = resize(PerspY, leftK, topBaseY);

			let topLeftXt = resize(PerspX, baseK, topLeftX);
			let topLeftYt = resize(PerspY, baseK, topLeftY);
			ctx.lineTo(topLeftXt, topLeftYt);

			// Аналогично, левая нижняя точка прямоугольно - запаздывание по коэфициенту базовой точки (baseX, baseY)
			let baseLeftX = resize(PerspX, leftK, baseX);
			let baseLeftY = resize(PerspY, leftK, baseY);
			let baseLeftXt = resize(PerspX, baseK, baseLeftX);
			let baseLeftYt = resize(PerspY, baseK, baseLeftY);
			ctx.lineTo(baseLeftXt, baseLeftYt);

			// Замыкаем прямоугольник в базовой точке, пересчитанной на коэф t
			ctx.lineTo(baseXt, baseYt);

			ctx.stroke();
			ctx.closePath()
		}
	}

	let bui = new building(1);
	let bui2 = new building(1.2);

	let t = 1;

	function startAnim() {
		setInterval(() => {
			ctx.clearRect(-SWidth/2, -SHeight/2, SWidth, SHeight);
			bui.draw(t);
			bui2.draw(t);
			drawPerspective();
			t = t*1.08;

			if (t> 450) {
				t = 1;
				bui = new building(1);
				bu2 = new building(166);
			}

			drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается

		}, 16);
	}
</script>

</html>