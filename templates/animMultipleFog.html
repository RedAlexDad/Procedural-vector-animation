<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>HTML5</title>
	<!--[if IE]>
   <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
	<style>
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas" width="800px" height="600px" style="border: 2px solid red;"></canvas>
	<button onclick="startAnim();">START</button>
</body>
<script>
	var started = false;
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");

	const SWidth = 800;						// Ширина сцены (canvas)
	const SHeight = 600;					// Высота сцены
	const PerspX = 0;						// Центр перспективы 0 в новой системе координат - в центре canvas
	const PerspY = -100;					// Центр перспективы по Y опускаем вниз на 100 пикселей
	const PCenter = { x: PerspX, y: PerspY }; // Центр перспективы в виде объекта
	const PLeft = { x: -SWidth/2, y: PerspY };
	const PRight = { x: SWidth/2, y: PerspY };

	const maxBotPerspTan = (SHeight/2 + PerspY) / (SWidth/2);
	const maxTopPerspTan = (SHeight/2 - PerspY) / (SWidth/2);

	function drawPerspective() {
		// Верхние линии перспективы
		ctx.strokeStyle = "rgb(0, 150, 150)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath()

		// Нижние линии перспективы
		ctx.strokeStyle = "rgb(0, 0, 0)";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(-SWidth / 2, -SHeight / 2);
		ctx.lineTo(PerspX, PerspY);
		ctx.lineTo(SWidth / 2, -SHeight / 2);
		ctx.stroke(); // Render the path
		ctx.closePath();

		// Линия горизонта
		ctx.strokeStyle = "rgb(0, 250, 250)";
		ctx.moveTo(-SWidth / 2, PerspY);
		ctx.lineTo(SWidth / 2, PerspY);
		ctx.stroke(); // Render the path	
		ctx.closePath()
	}

	function drawAxes() {
		ctx.font = "12px serif";
		ctx.strokeStyle = "red";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(50, 0);
		ctx.stroke(); // Render the path
		ctx.closePath()
		ctx.fillText("X", 50, 10);

		ctx.strokeStyle = "blue";
		ctx.beginPath(); // Start a new path
		ctx.moveTo(0, 0);
		ctx.lineTo(0, 50);
		ctx.stroke(); // Render the path
		ctx.closePath()
		ctx.fillText("Y", 0, 50);
	}

	drawAxes(); // Оси перед трансформацией

	//setTransform(a, b, c, d, e, f) - задать матрицу трансформаций для всех остальных рисований
	//	a	c	e
	//	b	d	f
	//	0	0	1
	// Cледющая трансформация сдвигает ось вправо на 400 пикселей и вниз на 300, т.е. в центр canvas
	// и отражает ось Y вверх (-1 в параметре d)
	ctx.setTransform(1, 0, 0, -1, 800 / 2, 600 / 2);
	drawAxes(); // рисуем новые оси, обратите внимание что текст теперь тоже отражается


	function resize(c, k, val) {
		return c + k * (val - c);
	}

	function moveToPoint(point) {
		ctx.moveTo(point.x, point.y);
	}

	function lineToPoint(point) {
		ctx.lineTo(point.x, point.y);
	}

	class point {
		// При конструировании присылаем объект - другую точку для копирования или просто JS-объект вида {x: 10, y: 12}
		constructor(pointObj = null) {
			if (pointObj && pointObj.x && pointObj.y) {
				this.x = pointObj.x;
				this.y = pointObj.y;
			} else {
				this.x = 0;
				this.y = 0;
			}
		}

		// Функции с окончанием -d не меняют текущий объект, а лишь возвращают временные пересчитанные координаты
		// это пригодиться для отрисовки базовых точек с искажением по времени без потери исходных координат
		moved(dx, dy) {
			return {
				x: this.x + dx,
				y: this.y + dy
			}
		}
		// Специально базирую функцию, меняющую объект на той, что не меняет, чтобы избежать повторения кода и чтобы обе функции работали одинаково
		// Таким образом если я поменяю чтото в формуле одной из них, то я не забуду сделать такое же изменение в другой
		move(dx, dy) {
			let moved = this.moved(dx, dy);
			this.x = moved.x;
			this.y = moved.y;
		}

		resized(centerPoint, k) {
			return {
				x: centerPoint.x + k * (this.x - centerPoint.x),
				y: centerPoint.y + k * (this.y - centerPoint.y)
			}
		}
		resize(centerPoint, k) {
			let resized = this.resized(centerPoint, k)
			this.x = resized.x;
			this.y = resized.y;
		}

		rotated(centerPoint, angle, isGrad = true) {
			if (isGrad) angle = angle * Math.PI / 180;
			return {
				x: (this.x - centerPoint.x) * Math.cos(angle) - (this.y - centerPoint.y) * Math.sin(angle) + centerPoint.x,
				y: (this.x - centerPoint.x) * Math.sin(angle) + (this.y - centerPoint.y) * Math.cos(angle) + centerPoint.y
			}
		}
		rotate(centerPoint, angle, isGrad = true) {
			let rotated = this.rotated(centerPoint, angle, isGrad);
			this.x = rotated.x;
			this.y = rotated.y;
		}

		dist2(pointObj = null) {
			let dx = 0;
			let dy = 0;

			if (pointObj && pointObj.x && pointObj.y) {
				dx = pointObj.x;
				dy = pointObj.y;
			}
		
			let dist = Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
			console.log(this, dx, dy, dist);
			return Math.pow(this.x - dx, 2) + Math.pow(this.y - dy, 2);
		}
		dist(pointObj = null) {
			return Math.sqrt(this.dist2(pointObj));
		}
	}

	class building {
		constructor(baseT) {
			this.baseT = baseT;

			this.baseWidth = 0.3;
			this.baseDepth = 0.1;

			this.widthRandCoef = Math.random()/2;
			this.heighRandCoef = Math.random() * 2 - 1;
			this.depthRandCoef = Math.random() * 2 - 1;

			this.baseRotRand = -Math.floor(Math.random()*16)*8-45; //*Math.atan(maxBotPerspTan)

			this.isLeft = (Math.random() < 0.5);

			this.dist = 0;
			this.points = {}
		}
		prepare(t) {
			this.baseK = (t-this.baseT) / 100; //(t - this.baseT) / 100;

			this.points.topBase = new point({x: 10, y: PCenter.y + SHeight/4})
			this.points.topBase.rotate(PCenter, this.baseRotRand);
			this.points.topBase.resize(PCenter, this.baseK);

			this.points.topLeft = new point(this.points.topBase);
			this.points.topLeft.resize(PCenter, 1-Math.min(this.baseWidth*this.baseK, this.baseWidth));

			this.points.topSide = new point(this.points.topBase);
			this.points.topSide.resize(PRight, 1-Math.min(this.baseDepth*this.baseK, this.baseWidth));

			this.points.topDepth = new point(this.points.topLeft);
			this.points.topDepth.resize(PRight, 1-Math.min(this.baseDepth*this.baseK, this.baseWidth));

			if (this.isLeft) {
				this.points.topBase.x = -this.points.topBase.x;
				this.points.topLeft.x = -this.points.topLeft.x;
				this.points.topSide.x = -this.points.topSide.x;
				this.points.topDepth.x = -this.points.topDepth.x;
			}

			this.points.botLeft = new point({x: this.points.topLeft.x, y: -SHeight});
			this.points.botBase = new point({x: this.points.topBase.x, y: -SHeight});
			this.points.botSide = new point({x: this.points.topSide.x, y: -SHeight});
		}

		draw() {
			/*ctx.beginPath();
			ctx.fillStyle = "rgb(100,0,0)";
			ctx.rect(this.points.topBase.x-3, this.points.topBase.y-3, 6, 6)
			ctx.fill();
			ctx.closePath();

			ctx.beginPath();
			ctx.fillStyle = "blue";
			ctx.rect(this.points.topLeft.x-3, this.points.topLeft.y-3, 6, 6)
			ctx.fill();
			ctx.closePath();

			ctx.beginPath();
			ctx.fillStyle = "green";
			ctx.rect(this.points.topSide.x-3, this.points.topSide.y-3, 6, 6)
			ctx.fill();
			ctx.closePath();

			ctx.beginPath();
			ctx.fillStyle = "yellow";
			ctx.rect(this.points.topDepth.x-3, this.points.topDepth.y-3, 6, 6)
			ctx.fill();
			ctx.closePath();

			
			ctx.beginPath();
			ctx.fillStyle = "black";
			ctx.rect(this.points.botBase.x-3, this.points.botBase.y-3, 6, 6)
			ctx.fill();
			ctx.closePath();*/


			let alpha = Math.min(this.baseK, 1.0);

			// заливаем весь контур здания белым чтобы предоствратить наложение двух полупрозрачных зданий друг на друга
			ctx.beginPath();
			ctx.fillStyle = "rgb(255,255,255)";
			moveToPoint(this.points.topDepth);
			lineToPoint(this.points.topLeft);
			lineToPoint(this.points.botLeft);
			lineToPoint(this.points.botSide);
			lineToPoint(this.points.topSide);
			lineToPoint(this.points.topDepth);
			ctx.fill();
			ctx.closePath()

			ctx.beginPath();
			ctx.fillStyle = "rgb(252,252,252,"+alpha+")";
			moveToPoint(this.points.topBase);
			lineToPoint(this.points.topLeft);
			lineToPoint(this.points.topDepth);
			lineToPoint(this.points.topSide);
			lineToPoint(this.points.topBase);
			ctx.fill();
			ctx.closePath()


			ctx.beginPath();
			if (this.isLeft) ctx.fillStyle = "rgb(247,247,247,"+alpha+")";
			else ctx.fillStyle = "rgb(200,200,230,"+alpha+")";
			lineToPoint(this.points.topSide);
			lineToPoint(this.points.botSide);
			lineToPoint(this.points.botBase);
			lineToPoint(this.points.topBase);
			ctx.fill();			
			ctx.closePath()
			

			ctx.beginPath();
			if (this.isLeft) ctx.fillStyle = "rgb(200,200,230,"+alpha+")";
			else ctx.fillStyle = "rgb(247,247,247,"+alpha+")";
			lineToPoint(this.points.botBase);
			lineToPoint(this.points.botLeft);
			lineToPoint(this.points.topLeft);
			lineToPoint(this.points.topBase);
			ctx.fill();
			ctx.closePath()
		}

		rotate(center, angle, isGrad = true) {
			Object.keys(bui.points).forEach(bpoint => {
				console.log(bpoint, typeof bpoint)
				bui.points[bpoint].rotate(center, angle, isGrad);
			})
		}
	}

	//let bui2 = new building(1.2);

	let t = 1;
	let nextBuldT = 1;
	let buildings = [new building(t)]; 

	function startAnim() {
		setInterval(() => {
			if (t >= nextBuldT) {
				let newBuilding = new building(t);
				let added = false;
				if (!added) {
					// добавления здания так, чтобы в массиве все было отсортировано по убыванию угла поворота baseRotRand
					for (let index = 0; index < buildings.length; index++) {
						const element = buildings[index];
						if (element.baseRotRand < newBuilding.baseRotRand) {
							buildings.splice((index > 0) ? index - 1 : 0, 0, newBuilding);
							added = true;
							break;
						}
					}
				}
				if (!added) {
					buildings.push(newBuilding);
					added = true;
				}
				
				nextBuldT = t + Math.floor(Math.random()*20+10);
				console.log(t, nextBuldT, buildings);
			}

			ctx.clearRect(-SWidth / 2, -SHeight / 2, SWidth, SHeight);

			for (let index = 0; index < buildings.length; index++) {
				const element = buildings[index];
				element.prepare(t);
				element.draw();
			}
			buildings = buildings.filter((bld) => {return (bld.baseK < 6);});

			//drawPerspective();
			t = t+1;
			//drawAxes();
		}, 16);
	}
</script>

</html>